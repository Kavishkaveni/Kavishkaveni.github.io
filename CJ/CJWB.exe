// CJ.cpp — QCM Credential Joiner (service + manual)
// - Listens on 127.0.0.1:5555; each line contains a UUID or "CJ/1 UUID=<uuid>"
// - For each UUID: GET http://<backend_host>:<backend_port>/cj/resolve/<uuid>
// - Expects JSON: {status, target_ip, target_port, protocol, username, password, ttl_secs}
// - Writes temp TERMSRV/<ip> cred via cmdkey, launches mstsc, then deletes it.
// - Also supports manual run: CJ.exe <uuid> <backend_host> <backend_port>
// Build: VS2017+  /MT, Unicode; link winhttp, shell32, advapi32, ws2_32
// VS2017 + newer SDKs: silence [[no_init_all]] attribute
#ifndef _NO_INIT_ALL
#define _NO_INIT_ALL 1
#endif
#ifdef _MSC_VER
#pragma warning(disable:5030) // 'unknown attribute' on VS2017
#endif

#ifndef UNICODE
#define UNICODE
#endif
#ifndef _UNICODE
#define _UNICODE
#endif
#define WIN32_LEAN_AND_MEAN


#include <windows.h>
#include <winhttp.h>
#include <shellapi.h>
#include <strsafe.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <string>
#include <vector>

#pragma comment(lib, "winhttp.lib")
#pragma comment(lib, "shell32.lib")
#pragma comment(lib, "advapi32.lib")
#pragma comment(lib, "ws2_32.lib")

// -------- logging -> C:\PAM\cj.log -----------------------------------------
static void LogF(PCWSTR fmt, ...)
{
	CreateDirectoryW(L"C:\\PAM", nullptr);
	wchar_t line[2048];
	va_list ap; va_start(ap, fmt);
	StringCchVPrintfW(line, _countof(line), fmt, ap);
	va_end(ap);

	SYSTEMTIME st; GetLocalTime(&st);
	wchar_t msg[2300];
	StringCchPrintfW(msg, _countof(msg),
		L"%04u-%02u-%02u %02u:%02u:%02u [CJ] %s\r\n",
		st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, line);

	HANDLE h = CreateFileW(L"C:\\PAM\\cj.log", FILE_APPEND_DATA, FILE_SHARE_READ,
		nullptr, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);
	if (h != INVALID_HANDLE_VALUE) {
		DWORD cb = (DWORD)(lstrlenW(msg) * sizeof(wchar_t));
		WriteFile(h, msg, cb, &cb, nullptr);
		CloseHandle(h);
	}
}

// -------- helpers -----------------------------------------------------------
static std::wstring ToW(const std::string& s) {
	if (s.empty()) return L"";
	int n = MultiByteToWideChar(CP_UTF8, 0, s.c_str(), (int)s.size(), nullptr, 0);
	std::wstring out(n, 0);
	MultiByteToWideChar(CP_UTF8, 0, s.c_str(), (int)s.size(), &out[0], n);
	return out;
}
static std::string ToA(const std::wstring& s) {
	if (s.empty()) return std::string();
	int n = WideCharToMultiByte(CP_UTF8, 0, s.c_str(), (int)s.size(), nullptr, 0, nullptr, nullptr);
	std::string out(n, 0);
	WideCharToMultiByte(CP_UTF8, 0, s.c_str(), (int)s.size(), &out[0], n, nullptr, nullptr);
	return out;
}

// Accept raw UUID or "CJ/1 UUID=<uuid>"
static std::wstring ExtractUuid(const std::wstring& line)
{
	// Fast path: looks like a UUID already
	if (line.size() >= 36 && line.find(L'-') != std::wstring::npos && line.find(L"UUID=") == std::wstring::npos) {
		return line;
	}
	// Look for UUID=........-....-....-....-............
	size_t p = line.find(L"UUID=");
	if (p != std::wstring::npos) {
		p += 5;
		std::wstring u = line.substr(p);
		// trim spaces/newline
		while (!u.empty() && (u.back() == L'\r' || u.back() == L'\n' || u.back() == L' ' || u.back() == L'\t')) u.pop_back();
		return u;
	}
	// Last token fallback
	size_t sp = line.find_last_of(L" \t");
	return (sp == std::wstring::npos) ? line : line.substr(sp + 1);
}

// --- tolerant JSON pickers --------------------------------------------------
// Returns the value as a UTF-8 string whether it was "quoted" or numeric
static std::string json_get_any(const std::string& body, const char* key)
{
	std::string needle = std::string("\"") + key + "\"";
	size_t p = body.find(needle);
	if (p == std::string::npos) return "";
	p = body.find(':', p);
	if (p == std::string::npos) return "";
	// skip spaces
	while (p < body.size() && (body[p] == ':' || body[p] == ' ' || body[p] == '\t')) ++p;
	if (p >= body.size()) return "";

	if (body[p] == '"') {
		size_t q = body.find('"', p + 1);
		if (q == std::string::npos) return "";
		return body.substr(p + 1, q - (p + 1));
	}
	else {
		// number or bare word up to , or }
		size_t q = p;
		while (q < body.size() && body[q] != ',' && body[q] != '}') ++q;
		// trim trailing spaces
		size_t r = q;
		while (r > p && (body[r - 1] == ' ' || body[r - 1] == '\t')) --r;
		return body.substr(p, r - p);
	}
}
static std::wstring json_ws(const std::string& body, const char* key) {
	return ToW(json_get_any(body, key));
}
static unsigned json_u32(const std::string& body, const char* key, unsigned defv) {
	std::string v = json_get_any(body, key);
	if (v.empty()) return defv;
	try { return (unsigned)std::stoul(v); }
	catch (...) { return defv; }
}

// --- HTTP GET ---------------------------------------------------------------
static bool http_get(const std::wstring& host, INTERNET_PORT port, const std::wstring& path, std::string& out)
{
	bool ok = false;
	HINTERNET s = WinHttpOpen(L"CJ/1.1", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
		WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0);
	if (!s) { LogF(L"WinHttpOpen failed ec=%lu", GetLastError()); return false; }

	HINTERNET c = WinHttpConnect(s, host.c_str(), port, 0);
	if (!c) { LogF(L"WinHttpConnect failed ec=%lu", GetLastError()); WinHttpCloseHandle(s); return false; }

	HINTERNET r = WinHttpOpenRequest(c, L"GET", path.c_str(), nullptr,
		WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, 0);
	if (!r) { LogF(L"WinHttpOpenRequest failed ec=%lu", GetLastError()); WinHttpCloseHandle(c); WinHttpCloseHandle(s); return false; }

	if (WinHttpSendRequest(r, WINHTTP_NO_ADDITIONAL_HEADERS, 0, 0, 0, 0, 0) &&
		WinHttpReceiveResponse(r, nullptr))
	{
		for (;;) {
			DWORD avail = 0;
			if (!WinHttpQueryDataAvailable(r, &avail)) { LogF(L"WinHttpQueryDataAvailable failed ec=%lu", GetLastError()); break; }
			if (avail == 0) { ok = true; break; }
			std::string chunk(avail, '\0');
			DWORD rd = 0;
			if (!WinHttpReadData(r, &chunk[0], avail, &rd)) { LogF(L"WinHttpReadData failed ec=%lu", GetLastError()); break; }
			if (rd == 0) { ok = true; break; }
			chunk.resize(rd);
			out.append(chunk);
		}
	}
	else {
		LogF(L"HTTP send/recv failed ec=%lu", GetLastError());
	}

	WinHttpCloseHandle(r);
	WinHttpCloseHandle(c);
	WinHttpCloseHandle(s);
	return ok;
}

// run console tool hidden
static DWORD runHidden(PCWSTR exe, std::wstring& cmdline)
{
	STARTUPINFOW si{}; si.cb = sizeof(si);
	si.dwFlags = STARTF_USESHOWWINDOW; si.wShowWindow = SW_HIDE;
	PROCESS_INFORMATION pi{};
	if (!CreateProcessW(exe, &cmdline[0], nullptr, nullptr, FALSE,
		CREATE_NO_WINDOW, nullptr, nullptr, &si, &pi)) {
		return GetLastError();
	}
	DWORD ec = 0;
	WaitForSingleObject(pi.hProcess, INFINITE);
	GetExitCodeProcess(pi.hProcess, &ec);
	CloseHandle(pi.hThread);
	CloseHandle(pi.hProcess);
	return ec;
}

// --- Core one-shot: resolve + mstsc ----------------------------------------
static void DoConnect(const std::wstring& uuid, const std::wstring& backendHost, INTERNET_PORT backendPort)
{
	LogF(L"Handle UUID=%s backend=%s:%u", uuid.c_str(), backendHost.c_str(), (unsigned)backendPort);

	std::wstring path = L"/cj/resolve/" + uuid;
	std::string body;
	if (!http_get(backendHost, backendPort, path, body)) {
		LogF(L"HTTP request failed");
		return;
	}
	LogF(L"RAW JSON: %s", ToW(body).c_str()); // <— critical for debugging

	std::wstring status = json_ws(body, "status");
	std::wstring ip = json_ws(body, "target_ip");
	unsigned     port = json_u32(body, "target_port", 3389);
	std::wstring user = json_ws(body, "username");
	std::wstring pass = json_ws(body, "password");
	unsigned     ttl = json_u32(body, "ttl_secs", 300);

	if (status != L"ok" || ip.empty() || user.empty() || pass.empty()) {
		LogF(L"Missing fields from backend");
		return;
	}
	LogF(L"Parsed ip=%s port=%u user=%s ttl=%u", ip.c_str(), port, user.c_str(), ttl);

	// Write temp TERMSRV/<ip> credential
	wchar_t sysdir[MAX_PATH] = { 0 };
	GetSystemDirectoryW(sysdir, MAX_PATH);
	std::wstring cmdkeyExe = std::wstring(sysdir) + L"\\cmdkey.exe";
	std::wstring target = L"TERMSRV/" + ip;

	std::wstring addLine = cmdkeyExe + L" /generic:" + target + L" /user:\"" + user + L"\" /pass:\"" + pass + L"\"";
	std::wstring addBuf = addLine;
	DWORD ecAdd = runHidden(cmdkeyExe.c_str(), addBuf);
	if (ecAdd == 0) LogF(L"CredWrite OK target=%s user=%s", target.c_str(), user.c_str());
	else LogF(L"cmdkey add failed ec=%lu", ecAdd);

	// Launch mstsc
	wchar_t args[256];
	StringCchPrintfW(args, _countof(args), L"/v:%s:%u /f", ip.c_str(), port);
	LogF(L"Launching: mstsc.exe %s", args);
	HINSTANCE h = ShellExecuteW(nullptr, L"open", L"mstsc.exe", args, nullptr, SW_SHOW);
	if ((INT_PTR)h <= 32) LogF(L"ShellExecute mstsc failed (%Id)", (INT_PTR)h);

	Sleep(20000); // allow mstsc to consume the cred
	std::wstring delLine = cmdkeyExe + L" /delete:" + target;
	std::wstring delBuf = delLine;
	DWORD ecDel = runHidden(cmdkeyExe.c_str(), delBuf);
	if (ecDel == 0) LogF(L"CredDelete OK target=%s", target.c_str());
	else LogF(L"CredDelete failed ec=%lu", ecDel);

	LogF(L"Cleanup done");
}

// ========================== Service bits ====================================
static const wchar_t* kSvcName = L"QCM-CJ";
static const wchar_t* kSvcDisp = L"QCM Credential Joiner";
static const wchar_t* kRegKey = L"SOFTWARE\\QCM\\CJ";
static const wchar_t* kRegHost = L"BackendHost";
static const wchar_t* kRegPort = L"BackendPort";
static const wchar_t* kRegListen = L"ListenPort"; // default 5555

static SERVICE_STATUS_HANDLE gSsh = nullptr;
static SERVICE_STATUS gSs{};

static void SvcSetState(DWORD s, DWORD exitCode = 0) {
	gSs.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
	gSs.dwCurrentState = s;
	gSs.dwWin32ExitCode = exitCode;
	gSs.dwControlsAccepted = (s == SERVICE_START_PENDING) ? 0 : (SERVICE_ACCEPT_SHUTDOWN | SERVICE_ACCEPT_STOP);
	SetServiceStatus(gSsh, &gSs);
}

static void ReadConfig(std::wstring& host, INTERNET_PORT& port, USHORT& listenPort)
{
	host = L"localhost"; port = 9000; listenPort = 5555;
	HKEY h; if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, kRegKey, 0, KEY_READ, &h) == ERROR_SUCCESS) {
		wchar_t buf[256]; DWORD cb = sizeof(buf), dw = 0, type = 0;
		if (RegQueryValueExW(h, kRegHost, 0, &type, (BYTE*)buf, &cb) == ERROR_SUCCESS && type == REG_SZ) host = buf;
		cb = sizeof(dw);
		if (RegQueryValueExW(h, kRegPort, 0, &type, (BYTE*)&dw, &cb) == ERROR_SUCCESS && type == REG_DWORD) port = (INTERNET_PORT)dw;
		cb = sizeof(dw);
		if (RegQueryValueExW(h, kRegListen, 0, &type, (BYTE*)&dw, &cb) == ERROR_SUCCESS && type == REG_DWORD) listenPort = (USHORT)dw;
		RegCloseKey(h);
	}
}

static DWORD WINAPI TcpWorker(LPVOID)
{
	std::wstring host; INTERNET_PORT port; USHORT listen;
	ReadConfig(host, port, listen);
	LogF(L"Service listen 127.0.0.1:%u backend=%s:%u", (unsigned)listen, host.c_str(), (unsigned)port);

	WSADATA w; if (WSAStartup(MAKEWORD(2, 2), &w) != 0) { LogF(L"WSAStartup failed"); return 0; }
	SOCKET s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (s == INVALID_SOCKET) { LogF(L"socket failed"); WSACleanup(); return 0; }

	sockaddr_in a{}; a.sin_family = AF_INET; a.sin_port = htons(listen);
	inet_pton(AF_INET, "127.0.0.1", &a.sin_addr);
	if (bind(s, (sockaddr*)&a, sizeof(a)) != 0 || (::listen(s, 16)) != 0) {
		LogF(L"bind/listen failed ec=%lu", WSAGetLastError()); closesocket(s); WSACleanup(); return 0;
	}

	for (;;) {
		fd_set fds; FD_ZERO(&fds); FD_SET(s, &fds);
		TIMEVAL tv{ 1,0 };
		int rv = select(0, &fds, nullptr, nullptr, &tv);
		if (gSs.dwCurrentState == SERVICE_STOP_PENDING) break;
		if (rv <= 0) continue;

		SOCKET c = accept(s, nullptr, nullptr);
		if (c == INVALID_SOCKET) continue;

		char buf[512]; int n = recv(c, buf, sizeof(buf) - 1, 0);
		if (n > 0) {
			buf[n] = 0;
			std::wstring line = ToW(std::string(buf, n));
			std::wstring uuid = ExtractUuid(line);
			LogF(L"Received UUID line: %s  -> uuid=%s", line.c_str(), uuid.c_str());
			DoConnect(uuid, host, port);
		}
		closesocket(c);
	}

	closesocket(s);
	WSACleanup();
	LogF(L"Service worker exit");
	return 0;
}

static void WINAPI SvcCtrl(DWORD ctrl) {
	if (ctrl == SERVICE_CONTROL_STOP || ctrl == SERVICE_CONTROL_SHUTDOWN) {
		LogF(L"Service stop requested");
		SvcSetState(SERVICE_STOP_PENDING);
	}
}
static void WINAPI SvcMain(DWORD, LPWSTR*) {
	gSsh = RegisterServiceCtrlHandlerW(kSvcName, SvcCtrl);
	if (!gSsh) return;
	SvcSetState(SERVICE_START_PENDING);
	HANDLE th = CreateThread(nullptr, 0, TcpWorker, nullptr, 0, nullptr);
	SvcSetState(SERVICE_RUNNING);
	WaitForSingleObject(th, INFINITE);
	CloseHandle(th);
	SvcSetState(SERVICE_STOPPED);
}

// ------- installer / uninstaller -------------------------------------------
static void ShowEula() {
	MessageBoxW(nullptr,
		L"QCM CJ — Terms & Conditions\n\n"
		L"This software initiates remote desktop sessions on your Jump Host based on UUIDs.\n"
		L"By clicking OK you agree to proceed.",
		L"QCM CJ Installer", MB_ICONINFORMATION | MB_OK);
}
static bool InstallSvc(const std::wstring& host, INTERNET_PORT port, USHORT listenPort)
{
	ShowEula();

	// write config
	HKEY h; if (RegCreateKeyExW(HKEY_LOCAL_MACHINE, kRegKey, 0, nullptr, 0, KEY_WRITE, nullptr, &h, nullptr) != ERROR_SUCCESS)
		return false;
	RegSetValueExW(h, kRegHost, 0, REG_SZ, (BYTE*)host.c_str(), (DWORD)((host.size() + 1) * sizeof(wchar_t)));
	DWORD dw = port;   RegSetValueExW(h, kRegPort, 0, REG_DWORD, (BYTE*)&dw, sizeof(dw));
	dw = listenPort;   RegSetValueExW(h, kRegListen, 0, REG_DWORD, (BYTE*)&dw, sizeof(dw));
	RegCloseKey(h);

	wchar_t path[MAX_PATH];
	GetModuleFileNameW(nullptr, path, MAX_PATH);

	SC_HANDLE scm = OpenSCManagerW(nullptr, nullptr, SC_MANAGER_CREATE_SERVICE);
	if (!scm) return false;
	SC_HANDLE svc = CreateServiceW(scm, kSvcName, kSvcDisp,
		SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS, SERVICE_AUTO_START,
		SERVICE_ERROR_NORMAL, (std::wstring(path) + L" --service").c_str(),
		nullptr, nullptr, nullptr, nullptr, nullptr);
	if (!svc) { CloseServiceHandle(scm); return false; }

	bool ok = (StartServiceW(svc, 0, nullptr) != 0);
	CloseServiceHandle(svc);
	CloseServiceHandle(scm);
	MessageBoxW(nullptr, L"Service installed and started.", L"CJ Installer", MB_OK | MB_ICONINFORMATION);
	return ok;
}
static void UninstallSvc()
{
	SC_HANDLE scm = OpenSCManagerW(nullptr, nullptr, SC_MANAGER_ALL_ACCESS);
	if (!scm) return;
	SC_HANDLE svc = OpenServiceW(scm, kSvcName, SERVICE_ALL_ACCESS);
	if (svc) {
		SERVICE_STATUS ss{};
		ControlService(svc, SERVICE_CONTROL_STOP, &ss);
		DeleteService(svc);
		CloseServiceHandle(svc);
	}
	CloseServiceHandle(scm);
	MessageBoxW(nullptr, L"Service uninstalled.", L"CJ Installer", MB_OK | MB_ICONINFORMATION);
}

// -------------------------------- main --------------------------------------
int wmain(int argc, wchar_t* argv[])
{
	if (argc >= 2 && lstrcmpiW(argv[1], L"--service") == 0) {
		SERVICE_TABLE_ENTRYW ste[] = { { (LPWSTR)kSvcName, SvcMain }, { nullptr, nullptr } };
		StartServiceCtrlDispatcherW(ste);
		return 0;
	}
	if (argc >= 2 && lstrcmpiW(argv[1], L"--uninstall") == 0) {
		UninstallSvc();
		return 0;
	}
	if (argc >= 4 && lstrcmpiW(argv[1], L"--install") == 0) {
		std::wstring host = argv[2];
		INTERNET_PORT port = (INTERNET_PORT)_wtoi(argv[3]);
		USHORT listen = (argc >= 5) ? (USHORT)_wtoi(argv[4]) : 5555;
		return InstallSvc(host, port, listen) ? 0 : 1;
	}

	if (argc < 4) {
		wprintf(L"Usage:\n"
			L"  CJ.exe --install <backend_host> <backend_port> [listen_port=5555]\n"
			L"  CJ.exe --uninstall\n"
			L"  (Service runs with: CJ.exe --service)\n\n"
			L"Manual test:\n"
			L"  CJ.exe <uuid> <backend_host> <backend_port>\n");
		return 1;
	}

	// Manual one-shot (useful for testing)
	std::wstring uuid = ExtractUuid(argv[1]);
	std::wstring host = argv[2];
	INTERNET_PORT port = (INTERNET_PORT)_wtoi(argv[3]);
	LogF(L"Start uuid=%s backend=%s port=%u", uuid.c_str(), host.c_str(), (unsigned)port);
	DoConnect(uuid, host, port);
	return 0;
}
